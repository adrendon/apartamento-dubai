"use strict";(self.webpackChunkmp_webgl=self.webpackChunkmp_webgl||[]).push([[9829],{43543:(e,t,s)=>{s.d(t,{v:()=>S,X:()=>A});var o=s(52947),r=s(68909);class i{constructor(){this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[],[]],this.boundingBox=null,this.boundingSphere=null}}class n{constructor(e,t,s,o,i,n=0){this.a=e,this.b=t,this.c=s,this.materialIndex=n,this.a=e,this.b=t,this.c=s,this.normal=o&&!Array.isArray(o)&&o.isVector3?o:new r.Vector3,this.vertexNormals=Array.isArray(o)?o:[],this.color=i&&!Array.isArray(i)&&i.isColor?i:new r.Color,this.vertexColors=Array.isArray(i)?i:[],this.materialIndex=n}clone(){return new n(this.a,this.b,this.c,this.normal,this.color).copy(this)}copy(e){this.a=e.a,this.b=e.b,this.c=e.c,this.normal.copy(e.normal),this.color.copy(e.color),this.materialIndex=e.materialIndex;for(let t=0,s=e.vertexNormals.length;t<s;t++)this.vertexNormals[t]=e.vertexNormals[t].clone();for(let t=0,s=e.vertexColors.length;t<s;t++)this.vertexColors[t]=e.vertexColors[t].clone();return this}}var a=s(97800),c=s(53172);const h=new a.Vy("surface-edge-finder"),l=new r.Triangle,u=["a","b","c"];class m extends n{constructor(e,t,s,o){super(e.a,e.b,e.c,e.normal),this.va=t,this.vb=s,this.vc=o,this.area=l.set(this.va.vector,this.vb.vector,this.vc.vector).getArea(),this.midpoint=l.getMidpoint(new r.Vector3),this.vertices=[this.va,this.vb,this.vc],t.faces.push(this),s.faces.push(this),o.faces.push(this)}}class f{constructor(e){this.vector=e,this.faces=[]}}class d{constructor(){this.area=0,this.normal=new r.Vector3,this.midpoint=new r.Vector3,this.faces=[],this.normalSum=new r.Vector3,this.midpointSum=new r.Vector3}add(e){e.surface&&e.surface.remove(e),this.faces.push(e),this.area+=e.area,this.midpointSum.add(e.midpoint),this.normalSum.add(e.normal),this.recalcFromSums(),e.surface=this}remove(e){e.surface&&(this.faces.splice(this.faces.indexOf(e),1),this.area-=e.area,this.midpointSum.sub(e.midpoint),this.normalSum.sub(e.normal),this.recalcFromSums()),e.surface=null}recalcFromSums(){this.normal.copy(this.normalSum).normalize(),this.midpoint.copy(this.midpointSum).divideScalar(this.faces.length)}mergeSurfaces(e){for(const t of e.faces)t.surface=this,this.faces.push(t);this.area+=e.area,this.normalSum.add(e.normalSum),this.midpointSum.add(e.midpointSum),this.recalcFromSums(),e.faces=[],e.area=0,e.normal.set(0,0,0),e.normalSum.set(0,0,0),e.midpointSum.set(0,0,0),e.midpoint.set(0,0,0)}getEdges(){const e={},t={};for(const t of this.faces)for(let s=0;s<3;s++){const o=t[u[s]],r=t[u[(s+1)%3]],i=Math.min(o,r)+","+Math.max(o,r);if(void 0===e[i]){const t={edge1:o,edge2:r,isEdge:!0};e[i]=t}else e[i].isEdge=!1}for(const{edge1:s,edge2:o,isEdge:r}of Object.values(e))r&&(t[s]||(t[s]=[]),t[s].push(o),t[o]||(t[o]=[]),t[o].push(s));return t}getCircularPaths(e){const t=this.getEdges(),s=new Set,o=[],r=Object.keys(t).map((e=>parseInt(e,10)));let i;for(;i=r.pop();){const r=[];for(;i;){let o;r.push(e[i]);let n=0;for(const r of t[i]){const t=Math.min(i,r)+","+Math.max(i,r);if(s.has(t))continue;const a=e[i].vector.distanceToSquared(this.midpoint);(void 0===o||a>n)&&(o=r,n=a)}if(!o)break;{const e=Math.min(i,o)+","+Math.max(i,o);s.add(e),i=o}}r.length>2&&o.push(r)}return o}}class p{constructor(){this.surfaces=new Set,this.lines=[],this.points=[]}*run(e,t=[1,5,10],s=.2,a=.01,l=20){const u=function(e){const t=new i,s=null!==e.index?e.index:void 0,o=e.attributes;if(void 0===o.position)throw Error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.");const a=o.position,c=o.normal,h=o.color,l=o.uv,u=o.uv2;void 0!==u&&(t.faceVertexUvs[1]=[]);for(let e=0;e<a.count;e++)t.vertices.push((new r.Vector3).fromBufferAttribute(a,e)),void 0!==h&&t.colors.push((new r.Color).fromBufferAttribute(h,e));function m(e,s,o,i=0){const a=void 0===h?[]:[t.colors[e].clone(),t.colors[s].clone(),t.colors[o].clone()],m=void 0===c?[]:[(new r.Vector3).fromBufferAttribute(c,e),(new r.Vector3).fromBufferAttribute(c,s),(new r.Vector3).fromBufferAttribute(c,o)],f=new n(e,s,o,m,a,i);t.faces.push(f),void 0!==l&&t.faceVertexUvs[0].push((new r.Vector2).fromBufferAttribute(l,e),(new r.Vector2).fromBufferAttribute(l,s),(new r.Vector2).fromBufferAttribute(l,o)),void 0!==u&&t.faceVertexUvs[1].push((new r.Vector2).fromBufferAttribute(u,e),(new r.Vector2).fromBufferAttribute(u,s),(new r.Vector2).fromBufferAttribute(u,o))}const f=e.groups;if(f.length>0)for(let e=0;e<f.length;e++){const t=f[e],o=t.start;for(let e=o,r=o+t.count;e<r;e+=3)void 0!==s?m(s.getX(e),s.getX(e+1),s.getX(e+2),t.materialIndex):m(e,e+1,e+2,t.materialIndex)}else if(void 0!==s)for(let e=0;e<s.count;e+=3)m(s.getX(e),s.getX(e+1),s.getX(e+2));else for(let e=0;e<a.count;e+=3)m(e,e+1,e+2);return t}(e),p=u.vertices.map((e=>new f(e))),g=[];for(const e of u.faces)g.push(new m(e,p[e.a],p[e.b],p[e.c])),yield;for(let e=0,t=g.length;e<t;e++){const t=g[e];(new d).add(t)}for(const e of t)yield*this.mergeSurfacesByNormal(g,e);for(const e of g)this.surfaces.add(e.surface);let v=0;const w=[];for(const e of this.surfaces){if(e.area<=s)continue;const t=e.getCircularPaths(p);for(const e of t)this.cullPath(e,((e,t)=>{if(e.length()<a||t.length()<a)return v++,!1;const s=e.angleTo(t)*c.tm;return!(s<l||s>180-l)||(v++,!1)})),e.length>2&&w.push(e);yield}h.debug(`Culled ${v} path points`);const y=new Set,b=new Set,S=e=>`${e.x.toFixed(3)},${e.y.toFixed(3)},${e.z.toFixed(3)}`,A=e=>`${S(e.start)}:${S(e.end)}`,N=e=>`${S(e.end)}:${S(e.start)}`;for(const e of w)for(let t=0;t<e.length;t++){const s=e[t].vector,r=e[(t+1)%e.length].vector,i=new o.cF(s,r),n=A(i),a=N(i),c=S(s);b.has(n)||b.has(a)||(b.add(n),b.add(a),this.lines.push(i)),y.has(c)||(y.add(c),this.points.push(new o.F7(s)))}yield}cullPath(e,t){const s=new r.Vector3,o=new r.Vector3;let i=!0;for(;i;){i=!1;for(let r=0;r<e.length&&e.length>2;r++){const n=e[0===r?e.length-1:r-1].vector,a=e[r].vector,c=e[(r+1)%e.length].vector;s.copy(n).sub(a),o.copy(c).sub(a),t(s,o)||(e.splice(r,1),i=!0,r--)}}}*mergeSurfacesByNormal(e,t,s=5){let o=-1,r=0;for(;0!==o&&r++<s;){h.debug(`Merging surfaces by normal angle threshold: ${t}`);const s=Math.cos(c.fy*t);o=0;let r=0;for(const t of e){r++%1e3==0&&(yield);for(const e of t.vertices)for(const r of e.faces){const e=r.surface;t.surface!==e&&t.surface.normal.dot(e.normal)>=s&&(t.surface.faces.length>e.faces.length?t.surface.mergeSurfaces(e):e.mergeSurfaces(t.surface),o++)}}o&&h.debug(`Merged ${o} surfaces by normal...`)}}}var g=s(27526),v=s(30443),w=s(77201);const y=new a.Vy("snapcaster");var b;!function(e){e[e.UNINITIALIZED=0]="UNINITIALIZED",e[e.WORKING=1]="WORKING",e[e.READY=2]="READY"}(b||(b={}));class S{constructor(e,t){this.cameraData=e,this.engine=t,this.meshes=new Map,this.newMeshes=new Set,this.raycaster=new r.Raycaster,this.filterSnapFeature=e=>{var t,s;const{meshName:o}=e;return!o||!1!==(null===(s=null===(t=this.meshes.get(o))||void 0===t?void 0:t.filter)||void 0===s?void 0:s.call(t,e))},this.cast=(e,t,s,i)=>{let n;s&&i&&(n=(new r.Plane).setFromNormalAndCoplanarPoint(i,s)),this.raycaster.set(e.origin,e.direction);const a=this.snappingOctree.raycast(this.raycaster,t,this.filterSnapFeature)||[],c=e=>{let t=(1+e.distance)*(1+e.distanceToRay)**2;return e.object instanceof o.F7&&(t/=10),n&&n.distanceToPoint(e.point)<-.2&&(t+=10),t};return a.sort(((e,t)=>c(e)-c(t))),a},this.add=(...e)=>{for(const t of e)this.snappingOctree.add(t)},this.remove=(...e)=>{for(const t of e)this.snappingOctree.remove(t)}}dispose(){this.meshes.clear(),this.newMeshes.clear(),this._snappingOctree.clear()}get snappingOctree(){return this.preloadMeshSnapping(),this._snappingOctree}setupOctree(e){this._snappingOctree=new o.Ay(e)}async preloadMeshSnapping(){var e;!this.populateProcess&&this.newMeshes.size&&(this.populateProcess=await this.engine.commandBinder.issueCommand(new g.i("snapping",this.buildSnappingForMeshes(),6e4)),await(null===(e=this.populateProcess)||void 0===e?void 0:e.promise),this.populateProcess=null)}*buildSnappingForMeshes(){const e=new r.Vector3;for(;;){let t=null;for(const s of this.newMeshes){const o=this.meshes.get(s);if(o){const{geometry:r}=o;if(!r){y.error("No mesh to generate snapping information from!"),o.status=b.READY;continue}const i=(0,v.UX)(r).getCenter(e).distanceTo(this.cameraData.pose.position);(!t||i<t.distance)&&(t={meshName:s,geometry:r,distance:i,info:o})}}if(!t)break;this.newMeshes.delete(t.meshName),t.info.status=b.WORKING,yield*this.buildSnappingForGeometry(t.geometry,t.info),t.info.status=b.READY,t.info.geometry=null,yield}y.info(`Snapping found ${this._snappingOctree.pointCount} points and ${this._snappingOctree.lineCount} lines`)}*buildSnappingForGeometry(e,t){e.computeVertexNormals(),yield;const s=new p;yield*s.run(e),y.debug(`Mesh done, added ${s.points.length} points and ${s.lines.length} lines`);for(const e of s.points)e.meshName=t.meshName,e.meta=t.meta,this._snappingOctree.add(e);for(const e of s.lines)e.meshName=t.meshName,e.meta=t.meta,this._snappingOctree.add(e);this.engine.broadcast(new A(s))}forEachSnapFeature(e,t=!1){this.snappingOctree.traverse((s=>{t&&!this.filterSnapFeature(s)||e(s)}))}addMeshGeometry(e,t,s,o){this.meshes.has(e)||(this.meshes.set(e,{meshName:e,geometry:t,status:b.UNINITIALIZED,meta:s,filter:o}),this.newMeshes.add(e))}removeMeshGeometry(e){const t=this.meshes.get(e);t&&t.status===b.UNINITIALIZED&&(this.meshes.delete(e),this.newMeshes.delete(e))}}class A extends w.QB{constructor(e){super(),this.edgeFinder=e}}},27526:(e,t,s)=>{s.d(t,{i:()=>r});var o=s(77201);class r extends o.uB{constructor(e,t,s,o=1){super(),this.payload={type:e,func:t,maxDelay:s,steps:o}}}r.id="SCHEDULE_PROCESS_COMMAND"},73427:(e,t,s)=>{s.d(t,{a:()=>h,e:()=>c});var o=s(2993),r=s(74381),i=s(86866),n=s(78498),a=s(66416);const c={[o.N3.Dollhouse]:r.nE.DOLLHOUSE,[o.N3.Floorplan]:r.nE.FLOORPLAN,[o.N3.Panorama]:r.nE.PANORAMA,[o.N3.Outdoor]:r.nE.PANORAMA,[o.N3.Transition]:r.nE.MESH,[o.N3.Orthographic]:r.nE.MESH,[o.N3.Mesh]:r.nE.MESH,[o.N3.ExteriorSplat]:r.nE.DOLLHOUSE};class h{constructor(){}serialize(e,t){if(!e.imageBlob)throw new Error("missing image to upload");const s=[];for(const[o,r]of e.metadata.floorVisibility.entries())if(1===r){const e=t.floorsData.getFloorAtIndex(o);e&&s.push(e.id)}return{label:e.name,contents:{filename:`${e.name}.jpg`,blob:e.imageBlob},snapshotLocation:{anchorId:e.metadata.scanId||void 0,visibleFloorIds:s,position:(0,n.I)(i.U$.toVisionVector(e.metadata.cameraPosition)),rotation:(0,n.p)(i.U$.toVisionCameraQuaternion(e.metadata.cameraQuaternion)),viewMode:c[e.metadata.cameraMode],zoom:e.metadata.cameraMode===o.N3.Floorplan?e.metadata.orthoZoom:e.metadata.ssZoom,showExterior:e.metadata.cameraMode===o.N3.ExteriorSplat},photoType:e.category===a.X.PANORAMA?r.xx.EQUIRECTANGULAR:r.xx.PHOTO2D}}}}}]);