"use strict";(self.webpackChunkmp_webgl=self.webpackChunkmp_webgl||[]).push([[3443],{17986:(t,e,o)=>{o.d(e,{A:()=>s});var i=o(77201);class s extends i.nV{constructor(){super(...arguments),this.name="base-controls",this.viewportControls=new Map,this.viewportBindings=new Map}setController(t,e){const o=this.viewportControls.get(t);o&&o.setController(e)}createControlsForViewport(t,e){const o=this.newControlsForViewport(t,e);this.viewportControls.set(t,o),this.viewportBindings.set(t,o.onActiveStateChanged((()=>this.onActiveStateChanged(o))))}removeControlsForViewport(t){const e=this.viewportBindings.get(t);e&&(e.cancel(),this.viewportBindings.delete(t));const o=this.viewportControls.get(t);o&&(o.setController(null),o.stop(),this.viewportControls.delete(t))}getControlsForViewport(t){const e=this.viewportControls.get(t);return e&&e.isActive?e:null}onActiveStateChanged(t){t.stop()}}},4994:(t,e,o)=>{o.d(e,{A:()=>s});var i=o(77201);class s{constructor(){this.poseControllerObservable=(0,i.pw)(null)}rotateBetweenOrientations(t,e,o,i,s){return console.warn("rotateBetweenOrientations(): not implemented"),Promise.resolve()}get poseController(){return this.poseControllerObservable.value}setController(t){return this.poseControllerObservable.value=t,this}get isActive(){return null!=this.poseController}onActiveStateChanged(t){return this.poseControllerObservable.onChanged(t)}}},35457:(t,e,o)=>{o.d(e,{P:()=>s});var i=o(77201);class s extends i.uB{constructor(t,e,o){super(),this.payload={enabled:t,previewCirclePosition:e,size:o}}}s.id="MESH_PREVIEW_POSITION"},73065:(t,e,o)=>{o.d(e,{V$:()=>l,g1:()=>a,ol:()=>r,qD:()=>s,vc:()=>n});var i=o(53172);const s=1e3/60,n=(0,i.pu)(70),r=-n,a=.05,l=.1/60},40742:(t,e,o)=>{o.r(e),o.d(e,{default:()=>O,lookAccelerationKey:()=>x});var i=o(68909),s=o(81662),n=o(73065),r=o(33007),a=o(3249),l=o(4994),c=o(77201),h=o(13893);class p extends l.A{constructor(t){super(),this.pose=t,this.lookVelocity=new i.Vector2,this.lookAccel=new i.Vector2,this.tempAxis=new i.Vector3,this.tempOrientation=new i.Quaternion,this.currentOrientation=new i.Quaternion,this.controlsEngaged=!1,this.tempEuler=new i.Euler,this.transition={active:!1,startTime:0,elapsed:0,progress:0,duration:0,updateParameters:{},easeOut:!1,externalTransitionActive:!0}}setController(t){return null==t&&this.stop(),super.setController(t)}setLookAcceleration(t,e=!1){this.transition.active||(e&&(t.x&&this.lookVelocity.x&&Math.sign(t.x)!==Math.sign(this.lookVelocity.x)&&(this.lookVelocity.x=0),t.y&&this.lookVelocity.y&&Math.sign(t.y)!==Math.sign(this.lookVelocity.y)&&(this.lookVelocity.y=0)),this.lookAccel.x=void 0!==t.x?t.x:this.lookAccel.x,this.lookAccel.y=void 0!==t.y?t.y:this.lookAccel.y)}async rotateBetweenOrientations(t,e,o,i,s=!1){if(!t)return this.startTransition(i,{startRotation:e,endRotation:o},!1,s).nativePromise();if(this.poseController){const t=this.pose.clone();return t.rotation.copy(o),this.poseController.moveTo({transitionType:h.fl.FadeToBlack,pose:t,transitionTime:i}).nativePromise()}}startTransition(t,e,o,i=!0){var s;const n=new c.iB;if(this.transition.active=!0,this.transition.duration=t,this.transition.elapsed=0,this.transition.startTime=Date.now(),this.transition.deferred=n,this.transition.easeOut=o,this.transition.externalTransitionActive=!i,this.transition.updateParameters=e,this.lookAccel.set(0,0),e.velocity)this.lookVelocity.copy(e.velocity),this.transition.updateParameters.velocity=e.velocity.clone(),this.transition.updateParameters.startRotation=this.transition.updateParameters.endRotation=void 0;else if(this.lookVelocity.set(0,0),!e.startRotation||!e.endRotation)throw new Error("startTransition: must specify velocity or both startRotation & endRotation");return i||null===(s=this.poseController)||void 0===s||s.beginExternalTransition(),n.promise()}stopTransition(){var t;const e=this.transition.active;this.transition.active&&(this.transition.externalTransitionActive&&(null===(t=this.poseController)||void 0===t||t.endExternalTransition()),this.transition.active=!1),this.transition.deferred&&(e&&this.transition.deferred.resolve(),this.transition.deferred=void 0)}updateTransitionForVelocityMovement(t,e){if(this.transition.updateParameters.velocity)if(this.lookVelocity.copy(this.transition.updateParameters.velocity),this.transition.elapsed>=this.transition.duration){const t=this.transition.duration-(this.transition.elapsed-e);this.lookVelocity.multiplyScalar(t/e)}else this.lookVelocity.multiplyScalar(t)}updateTransitionForRotationalMovement(){var t;if(!this.transition.updateParameters.startRotation||!this.transition.updateParameters.endRotation)return;const e=this.transition.updateParameters.startRotation,o=this.transition.updateParameters.endRotation;this.currentOrientation.copy(e).slerp(o,this.transition.progress),null===(t=this.poseController)||void 0===t||t.updateCameraRotation(this.currentOrientation)}updateTransition(t,e){this.transition.elapsed+=e,this.transition.progress=this.transition.elapsed/this.transition.duration,this.transition.updateParameters.velocity?this.updateTransitionForVelocityMovement(t,e):this.updateTransitionForRotationalMovement()}updateCameraParametersForVelocityMovement(){var t;const e=this.pose;this.tempEuler.setFromQuaternion(e.rotation,"YXZ");const o=this.tempEuler.x,i=(0,a.qE)(this.lookVelocity.y,n.ol-o,n.vc-o);this.tempAxis.copy(s.B1.RIGHT),this.tempOrientation.setFromAxisAngle(this.tempAxis.applyQuaternion(e.rotation),i),this.currentOrientation.copy(e.rotation).premultiply(this.tempOrientation),this.tempOrientation.setFromAxisAngle(s.B1.UP,this.lookVelocity.x),this.currentOrientation.premultiply(this.tempOrientation),e.rotation.equals(this.currentOrientation)||(this.tempOrientation.copy(this.currentOrientation).normalize(),null===(t=this.poseController)||void 0===t||t.updateCameraRotation(this.tempOrientation))}update(t){this.pose.rotation.equals(this.currentOrientation)||this.currentOrientation.copy(this.pose.rotation);const e=t/n.qD;this.transition.active?(this.updateTransition(e,t),this.transition.updateParameters.velocity&&this.updateCameraParametersForVelocityMovement(),this.transition.elapsed>=this.transition.duration&&(this.stop(this.transition.easeOut),this.transition.active=!1)):(this.lookAccel.length()>r.A.epsilon||this.lookVelocity.length()>r.A.epsilon)&&(this.lookVelocity.addScaledVector(this.lookAccel,e),this.updateCameraParametersForVelocityMovement(),this.lookVelocity.multiplyScalar(Math.pow(1-n.g1,e)))}stop(t=!1){this.stopTransition(),this.lookAccel.set(0,0),t||this.lookVelocity.set(0,0)}startRotateTransition(t,e,o){return this.beforeStartRotationTransition&&this.beforeStartRotationTransition(),this.startTransition(t,{velocity:e.clone().multiplyScalar(n.qD)},o).nativePromise()}startTranslateTransition(t,e,o=!0){throw new Error("Panning isn't supported in Panorama Controls")}startZoomTransition(t,e,o){throw new Error("Zooming isn't supported in Panorama Controls")}}var d=o(90834),u=o(2993),v=o(72268),m=o(71397),y=o(28337),w=o(94790),A=o(60043),g=o(25316),k=o(71687),C=o(10459),V=o(17986);const x="Rotation speed";class O extends V.A{constructor(){super(...arguments),this.name="panorama-controls",this.lookAccelerationSpeed=n.V$,this.calcRotationAngle=(()=>{const t=new i.Matrix4,e=new i.Vector3,o=new i.Vector3;return(s,n)=>{t.copy(this.cameraData.pose.projection.asThreeMatrix4()),t.invert(),e.set(s.x-n.x,s.y-n.y,-1).applyMatrix4(t),o.set(s.x,s.y,-1).applyMatrix4(t);const r=Math.sqrt(e.x*e.x+e.z*e.z),a=Math.sqrt(o.x*o.x+o.z*o.z),l=Math.atan2(e.y,r),c=Math.atan2(o.y,a)-l;e.y=0,o.y=0,e.normalize(),o.normalize();const h=Math.acos(e.dot(o));let p=0;return isNaN(h)||(p=h,n.x>0&&(p*=-1)),new i.Vector2(-p,-c)}})()}async init(t,e){const o=await e.getModuleBySymbol(k.X7);[this.cameraData,this.viewportModule]=await Promise.all([e.market.waitForData(C.M),e.getModuleBySymbol(k.Qm)]),o.addControls(u.N3.Panorama,this),o.addControls(u.N3.Mesh,this),this.market=e.market,e.getModuleBySymbol(k.mL).then((t=>{t.registerHandler(w.SK,(t=>{if(!this.shouldBeActive())return;const e=this.getControlsForViewport(t.viewportId);e&&e.stop()})),t.registerHandler(w.jF,(t=>{if(this.shouldBeActive()&&t.buttons&v.O.PRIMARY){const e=this.getControlsForViewport(t.viewportId);if(!e)return;e.controlsEngaged=!0,this.onDrag(e,t.position,t.delta),e.update(n.qD),e.stop()}})),t.registerHandler(w._w,(t=>{const e=this.getControlsForViewport(t.viewportId);e&&this.shouldBeActive()&&e.controlsEngaged&&(t.timeSinceLastMove<100&&!(t.buttons&v.O.PRIMARY)&&(this.onDrag(e,t.position,t.delta),e.update(n.qD),e.setLookAcceleration({x:0,y:0})),e.controlsEngaged=!1)})),t.registerHandler(A.k,(t=>{this.shouldBeActive()&&this.onKey(t.key,t.state)}))}))}onUpdate(t){if(this.shouldBeActive())for(const e of this.viewportControls.values())e.update(t)}newControlsForViewport(t,e){const o=new p(e);return o.beforeStartRotationTransition=()=>{const t=this.cameraData.transition;t&&t.activeInternal&&t.to.rotation&&(t.to.rotation=void 0)},o}onDrag(t,e,o){t.setLookAcceleration(this.calcRotationAngle(e,o))}onKey(t,e){var o,i;const s=this.getControlsForViewport(this.viewportModule.viewportManager.activeViewport.id);if(!s)return;const n=null!==(i=null===(o=this.market.tryGetData(g.o))||void 0===o?void 0:o.tryGetSetting(x,null))&&void 0!==i?i:null;this.lookAccelerationSpeed=n?n*(Math.PI/180)/60:this.lookAccelerationSpeed;const r=e===y.$.DOWN;switch(t){case m.D.LEFTARROW:case m.D.J:s.setLookAcceleration({x:r?this.lookAccelerationSpeed:0},!0);break;case m.D.RIGHTARROW:case m.D.L:s.setLookAcceleration({x:r?-this.lookAccelerationSpeed:0},!0);break;case m.D.K:s.setLookAcceleration({y:r?-this.lookAccelerationSpeed:0},!0);break;case m.D.I:s.setLookAcceleration({y:r?this.lookAccelerationSpeed:0},!0)}}shouldBeActive(){var t,e;return!(null!==(e=null===(t=this.market.tryGetData(d.O))||void 0===t?void 0:t.isVR())&&void 0!==e&&e)}}},39118:(t,e,o)=>{o.d(e,{l:()=>s});var i=o(77201);class s extends i.uB{constructor(t){super(),this.payload={roomAssociation:t}}}s.id="REGISTER_ROOM_ASSOCIATION_SOURCE"}}]);