"use strict";(self.webpackChunkmp_webgl=self.webpackChunkmp_webgl||[]).push([[8893],{77201:(e,t,s)=>{s.d(t,{PF:()=>n,DF:()=>ke,Jj:()=>B,uv:()=>Le,lg:()=>U,E5:()=>Ae,zH:()=>G,Fj:()=>Se,av:()=>g,Xw:()=>_e,Th:()=>Ke,uB:()=>he,we:()=>le,rm:()=>Ne,B_:()=>A,xj:()=>pe,pe:()=>Qe,wo:()=>u,N$:()=>dt,c2:()=>re,ct:()=>we,Ch:()=>ae,Gs:()=>i,nF:()=>qe,Fy:()=>Te,QB:()=>ve,QY:()=>Pe,nV:()=>ce,VA:()=>Me,oN:()=>Y,cP:()=>O,XD:()=>Be,Es:()=>Ge,q8:()=>He,vm:()=>P,g$:()=>Ve,yy:()=>je,Lj:()=>M,iB:()=>We.i,CV:()=>De,hB:()=>Ee,yF:()=>$e,Gq:()=>oe,HU:()=>me,aX:()=>$,L0:()=>j,$Q:()=>c,m0:()=>f,Zy:()=>ye,Rb:()=>fe,T6:()=>H,sv:()=>te,i_:()=>y,Zg:()=>xe,_Q:()=>b,y3:()=>Fe,cD:()=>N,pw:()=>T,Rv:()=>ze,Ks:()=>q,f9:()=>m,Sh:()=>l,oV:()=>Q,UV:()=>R});const i={};var r=s(97800);class n{constructor(...e){this.subs=e}renew(){for(const e of this.subs)e.renew()}cancel(){for(const e of this.subs)e.cancel()}}const o=new r.Vy("Subscription");class a{constructor(e,t,s){this.watchedData=e,this.registerSubscription=t,this.unregisterSubscription=s}createSubscription(e,t){return new d((()=>this.registerSubscription(e)),(()=>this.unregisterSubscription(e)),t)}getData(){return this.watchedData()}}class h{constructor(e,t,s,i){this.collection=e,this.itemProperty=t,this.subscribeFcn=s,this.unsubcribeFcn=i}createSubscription(e,t){const s=[],i=new d((()=>{for(const t of this.collection){const i=()=>e(t,this.itemProperty);s.push(i),this.subscribeFcn(t,i)}}),(()=>{let e=0;for(const t of this.collection)this.unsubcribeFcn(t,s[e]),e++}),t);return this.collection.hasOwnProperty("isObservable")?(this.collection.onElementChanged({onAdded:t=>{s.push((()=>e(t,this.itemProperty))),i.active&&this.subscribeFcn(t,s[s.length-1])},onRemoved:e=>{let t=0;for(const s of this.collection){if(s===e)break;t++}this.unsubcribeFcn(e,s[t]),s.splice(t,1)}}),i):i}getData(){return this.collection}}class d{constructor(e,t,s=!1,i=""){this.startSubscription=e,this.endSubscription=t,this.id=i,this.isSubbed=!1,s&&this.renew()}renew(){this.isSubbed?o.debugWarn(`Duplicate subscription renew ${this.id}`):(this.startSubscription(),this.isSubbed=!0)}cancel(){this.isSubbed&&(this.endSubscription(),this.isSubbed=!1)}get active(){return this.isSubbed}}function l(e,t,s=!0,i=""){return new d(e,t,s,i)}class c{constructor(e){this.map=new Map,e.forEach((e=>this.map.set(e.state,e.subs)))}renew(e){(this.map.get(e)||[]).forEach((e=>e.renew()))}cancel(e){if(e){(this.map.get(e)||[]).forEach((e=>e.cancel()))}else this.map.forEach((e=>e.forEach((e=>e.cancel()))))}update(e,t){this.map.set(e,t)}}class u{constructor(e,t,s,i){this.target=e,this.type=t,this.listener=s,this.options=i,this.renew()}renew(){this.target.addEventListener(this.type,this.listener,this.options)}cancel(){this.target.removeEventListener(this.type,this.listener,this.options)}}function m(e,t=16){let s;const i=l((()=>s=window.setInterval((()=>e()),t)),(()=>{s&&clearInterval(s)}));return i.cancel(),i}class f{constructor(){this.callbacks=new Set}add(e){return l((()=>this.callbacks.add(e)),(()=>this.callbacks.delete(e)))}triggerCb(...e){for(const e of this.callbacks)e(...arguments)}}var p,g;!function(e){e[e.ADDED=0]="ADDED",e[e.REMOVED=1]="REMOVED",e[e.UPDATED=2]="UPDATED",e[e.COUNT=3]="COUNT"}(p||(p={})),function(e){e[e.ADDED=1]="ADDED",e[e.REMOVED=2]="REMOVED",e[e.UPDATED=4]="UPDATED",e[e.ALL=7]="ALL"}(g||(g={}));const b=(e,t)=>{const s=t&g.ADDED,i=t&g.REMOVED,r=t&g.UPDATED,n={};let o;return new a((()=>e),(t=>o=e.onElementChanged((e=>(n.onAdded=s?e:void 0,n.onRemoved=i?e:void 0,n.onUpdated=r?e:void 0,n))(t))),(e=>{o&&o.cancel()}))},y=(e,t)=>new h(e,t,((e,s)=>e.onPropertyChanged(t,s)),((e,s)=>e.removeOnPropertyChanged(t,s)));var v=s(52718),w=s(80826),C=s(27291);class O{constructor(){this.isObservable=!0,this._dirtyObservable=!1,this._activeObservable=!0,this._observerNotifying=!1,this._changeObservers=new Set,this._parentObservables=new Set,this._childObservables=new Set,Object.defineProperties(this,{isObservable:{value:this.isObservable,writable:!1,enumerable:!1},_dirtyObservable:{value:this._dirtyObservable,enumerable:!1},_activeObservable:{value:this._activeObservable,enumerable:!1},_observerNotifying:{value:this._observerNotifying,enumerable:!1},_changeObservers:{value:this._changeObservers,writable:!1,enumerable:!1},_childObservables:{value:this._childObservables,writable:!1,enumerable:!1},_parentObservables:{value:this._parentObservables,writable:!1,enumerable:!1}})}onChanged(e){if(this._changeObservers.has(e))throw new Error("This observer function is already observing this Observable, and double subscriptions are not supported.");return l((()=>this._changeObservers.add(e)),(()=>this.removeOnChanged(e)),!0)}removeOnChanged(e){this._changeObservers.delete(e)}notifyObservers(){if(this._dirtyObservable&&!this._observerNotifying&&this._activeObservable){this._observerNotifying=!0;for(const e of this._changeObservers)this.notifyObserver(e);this._dirtyObservable=!1,this._observerNotifying=!1}}notifyObserver(e){e(void 0)}notifyDown(){for(const e of this._childObservables)e.notifyDown();this.notifyObservers()}notifyUp(){for(const e of this._parentObservables)e.notifyUp();this.notifyObservers()}setDirty(e=!0){this.setDirtyUp(),e&&this.notifyUp()}setDirtyUp(){if(!this._dirtyObservable){this._dirtyObservable=!0;for(const e of this._parentObservables)e.setDirtyUp()}}addChildObservable(e){O.isObservable(e)&&(this._childObservables.add(e),e._parentObservables.add(this))}removeChildObservables(e){O.isObservable(e)&&(this._childObservables.delete(e),e._parentObservables.delete(this))}atomic(e){if(!this._activeObservable)return e();try{this.setActive(!1),e()}finally{this.setActive(!0)}}setActive(e){const t=this._activeObservable;this._activeObservable=e,!t&&e&&this.notifyObservers();for(const t of this._childObservables)t.setActive(e)}deepCopy(){throw Error("deepCopy is only implemented in subclasses of Observable")}get asRxJS$(){return this._rxJS$||(this._rxJS$=new v.c((e=>{const t=this.onChanged((t=>{e.next(t)}));return()=>{this._rxJS$=null,t.cancel()}})).pipe((0,w.u)({connector:()=>new C.B,resetOnRefCountZero:!0}))),this._rxJS$}static isObservable(e){return e&&e.isObservable}}const k=new r.Vy("ObservableObject"),_=1===(0,r.P3)("debug",0);class P extends O{constructor(){super(),this._propertyObservables={},this._valueCache={},this._dirtyKeys=new Set,Object.defineProperties(this,{_propertyObservables:{value:this._propertyObservables,writable:!1,enumerable:!1},_valueCache:{value:this._valueCache,writable:!1,enumerable:!1},_dirtyKeys:{value:this._dirtyKeys,writable:!1,enumerable:!1}}),_&&setTimeout((()=>{!function(e){const t={};for(const s in e)e.hasOwnProperty(s)&&(t[s]=e[s],e._valueCache[s]=e[s],Object.defineProperty(e,s,{get:()=>t[s],set:i=>{const r=e._valueCache[s];(r!==i||O.isObservable(r)&&r._dirtyObservable)&&E(e,s),t[s]=i},enumerable:!0}))}(this)}),1)}onPropertyChanged(e,t){const s=e;if(this._propertyObservables[s]||(this._propertyObservables[s]=new Set),this._propertyObservables[s].has(t))throw new Error("This observer function is already observing this Observable, and double subscriptions are not supported.");return l((()=>this._propertyObservables[s].add(t)),(()=>this.removeOnPropertyChanged(e,t)),!0,s)}removeOnPropertyChanged(e,t){const s=e;this._propertyObservables[s].delete(t)}commit(){this.setDirtyUp(),this.notifyUp()}setDirtyUp(){for(const e in this){if(!this.hasOwnProperty(e))continue;const t=this._valueCache[e],s=this[e];t!==s?(this.removeChildObservables(t),this.addChildObservable(s),this._valueCache[e]=s,this._dirtyKeys.add(e)):O.isObservable(t)&&t._dirtyObservable&&this._dirtyKeys.add(e)}super.setDirtyUp()}notifyObservers(){if(this._dirtyObservable&&!this._observerNotifying&&this._activeObservable){this._observerNotifying=!0;for(const e of this._dirtyKeys){for(const t of this._propertyObservables[e]||[])this.notifyPropertyObserver(t,e);_&&L(this,e)}this._observerNotifying=!1,this._dirtyKeys.clear()}super.notifyObservers()}notifyPropertyObserver(e,t){e(this._valueCache[t])}notifyObserver(e){e(this)}deepCopy(){const e={};for(const t in this)this.hasOwnProperty(t)&&(e[t]=(0,r.A4)(this[t]));return e}}const D=new Map;function E(e,t){D.has(e)||D.set(e,{});D.get(e)[t]=Error()}function L(e,t){if(D.has(e)){const s=D.get(e);s[t]&&delete s[t]}}if(_){const e=setInterval((()=>{(function(){for(const e of D.values())for(const t in e)return k.error(`ObservableObject property "${t}" was still dirty after one tick! Did you forget a .commit()?`),k.error("See stack trace of the property write below:"),k.error(e[t].stack),!0;return!1})()&&void 0!==e&&clearInterval(e)}),16)}class A extends P{}function S(e,t){const s=Object.getOwnPropertyNames(t);for(const i of s)void 0===e[i]&&("function"==typeof t[i]?Object.defineProperty(e,i,{value:t[i].bind(e)}):Object.defineProperty(e,i,{value:t[i],writable:!0}));null!==Object.getPrototypeOf(Object.getPrototypeOf(t))&&S(e,Object.getPrototypeOf(t))}function R(e,t){return new Promise((s=>{if(t(e))s();else{const i=e.onChanged((()=>{t(e)&&(i.cancel(),s())}))}}))}function I(e,t){return e instanceof Function?e(t):t===e}class M extends O{constructor(e){super(),this.value=e}notifyObserver(e){e(this.value)}get value(){return this._value}set value(e){this._value!==e&&(this.removeChildObservables(this._value),this.addChildObservable(e),this._value=e,this.setDirty())}deepCopy(){return(0,r.A4)(this._value)}waitFor(e){return new Promise((t=>{if(I(e,this._value))t();else{const s=this.onChanged((i=>{I(e,i)&&(s.cancel(),t())}))}}))}}const T=e=>new M(e),N=e=>{if(!e||0===Object.keys(e).length)throw new Error("createObservableProxy() only works on objects that has predefined keys. Did you mean createObservableMap or createObservableArray?");if(e instanceof P)throw new Error("Using ObservableProxy on an ObservableObject is a BUG!");if(e.isObservableProxy)return e;const t={},s=new O,i=Object.create(e);Object.defineProperties(i,{isObservableProxy:{value:!0},onPropertyChanged:{value:(e,s)=>t[e].onChanged(s)},removeOnPropertyChanged:{value:(e,s)=>t[e].removeOnChanged(s)},deepCopy:{value:()=>(0,r.A4)(e)}}),S(i,s);for(const s in e)if(e.hasOwnProperty(s)){const r=T(e[s]);t[s]=r,i.addChildObservable(r),Object.defineProperty(i,s,{get:()=>e[s],set:i=>{e[s]=i,t[s].value=i},enumerable:!0})}return Object.seal(i),i};var B;!function(e){e[e.UNINITIALIZED=0]="UNINITIALIZED",e[e.WAITING=1]="WAITING",e[e.LOADING=2]="LOADING",e[e.STARTING=3]="STARTING",e[e.PLAYING=4]="PLAYING",e[e.ERROR=5]="ERROR"}(B||(B={}));const x=["UNINITIALIZED","WAITING","LOADING","STARTING","PLAYING","ERROR"];var U;!function(e){e.UNKNOWN="unknown",e.WEBVR="webvr",e.SHOWCASE="showcase",e.WORKSHOP="workshop"}(U||(U={}));class G extends A{constructor(e,t=U.UNKNOWN){super(),this.name="app-data",this.phases=B,this.editMode=!1,this.playingPromise=new r.iB,this.startingPromise=new r.iB,this.phase=e,this.application=t,this.phaseTimes=N({[B.UNINITIALIZED]:0,[B.WAITING]:0,[B.LOADING]:0,[B.STARTING]:0,[B.PLAYING]:0,[B.ERROR]:0}),this.error=null,this.onPhase((()=>{this.playingPromise.resolve()}),B.PLAYING),this.onPhase((()=>{this.startingPromise.resolve()}),B.STARTING)}getName(){return this.application.toString()}getVersion(){return"26.1.1_webgl-90-g894b4d3f55"}onPhase(e,t){return this.onPropertyChanged("phase",(s=>{t&&s!==t||e()}))}get waitForPlaying(){return this.playingPromise.nativePromise()}toString(){return JSON.stringify({application:this.getName(),version:this.getVersion(),error:this.error,phaseTimes:this.phaseTimes})}}var F=s(65945);const V="__isRoot__",H="__workshopLoadCalledOnce__",j="__showcaseLoadCalledOnce__",$="__sdkInterfacesSetupCalled__",z=new r.Vy("di-container"),Q=new F.mc;Q.bindConstant(V,!0);const K={};function q(e){return z.warn("Prefer getting container directly from engine for better encapsulation."),K[e]}var W,Z;(function(e){e[e.None=0]="None",e[e.Duration=1]="Duration",e[e.Phase=2]="Phase",e[e.Promise=3]="Promise"})(W||(W={}));class J{constructor(e){this.type=e}}class Y extends J{constructor(){super(W.None)}}class X extends J{constructor(e){super(W.Duration),this.duration=e,this.startTime=Date.now()}}class ee extends J{constructor(e){super(W.Phase),this.phase=e}}!function(e){e[e.Pending=0]="Pending",e[e.Fulfilled=1]="Fulfilled",e[e.Rejected=2]="Rejected"}(Z||(Z={}));class te extends J{constructor(e){super(W.Promise),this.promise=e,this.promiseState=Z.Pending,e.then((()=>{this.promiseState=Z.Fulfilled})).catch((()=>{this.promiseState=Z.Rejected}))}}class se{constructor(e,t=!0){this.generator=e,t&&this.start()}start(){this.started||(this.iterator=this.generator()),this.started=!0}iterate(){const e=this.iterator.next();this.currentResult=e.value,e.done&&(this.started=!1)}}class ie{constructor(){this.generators=[]}startGenerator(e){let t=this.generators.length;for(let s=0;s<this.generators.length;s++){this.generators[s].generator===e&&(t=s)}this.generators[t]=new se(e)}stopGenerator(e){for(const t of this.generators)t.generator===e&&(t.started=!1)}processGenerators(e,t){for(const s of this.generators)if(s.started)switch(e){case W.None:(!s.currentResult||s.currentResult instanceof Y)&&s.iterate();break;case W.Phase:if(s.currentResult instanceof ee){const e=s.currentResult;void 0!==t&&e.phase===t&&s.iterate()}break;case W.Promise:if(s.currentResult instanceof te){s.currentResult.promiseState===Z.Fulfilled&&s.iterate()}break;case W.Duration:if(s.currentResult instanceof X){const e=s.currentResult;Date.now()-e.startTime>=e.duration&&s.iterate()}}}}class re{constructor(e,t,s){this.engine=e,this.renderer=t,this.onErrorCallback=s,this.start=()=>{this.renderer.setAnimationLoop(this.tick)},this.stop=()=>{this.renderer.setAnimationLoop(null)},this.tick=e=>{try{this.engine.tick()}catch(e){this.stop(),this.onErrorCallback(e)}}}}var ne,oe;!function(e){e[e.CANCELLED=0]="CANCELLED",e[e.COMPLETED=1]="COMPLETED"}(ne||(ne={})),function(e){e[e.COMPUTE=0]="COMPUTE",e[e.BACKGROUND=1]="BACKGROUND"}(oe||(oe={}));class ae{constructor(){this.name="generator-spreader",this.computeQueue=[],this.backgroundQueue=[]}enqueue(e,t,s=oe.COMPUTE,i=!1){this.cancel(e,s);const n=this.getQueue(s),o=new r.iB;return i?n.unshift({id:e,generator:t,promise:o}):n.push({id:e,generator:t,promise:o}),o.nativePromise()}cancel(e,t=oe.COMPUTE){const s=this.getQueue(t),i=this.indexOfId(e,t);if(-1!==i){const e=s[i];s.splice(i,1),e.promise.resolve({state:ne.CANCELLED,result:null})}}indexOfId(e,t){const s=this.getQueue(t);let i=-1;for(let t=0;t<s.length;t++)if(e===s[t].id){i=t;break}return i}getQueue(e){return e===oe.COMPUTE?this.computeQueue:this.backgroundQueue}hasTasks(e=oe.COMPUTE){return this.getQueue(e).length>0}hasTask(e,t=oe.COMPUTE){return-1!==this.indexOfId(e,t)}onUpdate(){const e=performance.now();for(;performance.now()-e<15&&this.computeQueue.length>0;){const e=this.computeQueue[0],{value:t,done:s}=e.generator.next();s&&(this.computeQueue.splice(0,1),e.promise.resolve({state:ne.COMPLETED,result:t}))}const t=performance.now();for(;performance.now()-t<3&&this.backgroundQueue.length>0;){const e=this.backgroundQueue[0],{value:t,done:s}=e.generator.next();s&&(this.backgroundQueue.splice(0,1),e.promise.resolve({state:ne.COMPLETED,result:t}))}}}class he{get id(){return this.constructor.id}}const de=new r.Vy("command-binder");class le{constructor(e=!1){this.ignoreUnboundCommands=e,this.bindings={},this.queuedCommands={},this.hookedCommands={},this.resetHooks=()=>{this.hookedCommands={}},this.issueCommand=this.issueCommand.bind(this),this.issueCommandWhenBound=this.issueCommandWhenBound.bind(this)}addBinding(e,t){if(this.bindings[e.id])throw Error(`Command ${e.id} already bound to a callback`);if(!e.id)throw Error(`Command ${e.name} does not have an id. Add one as a static member.`);this.bindings[e.id]=t,this.callQueuedCommands(e.id);return{renew:()=>{this.bindings[e.id]!==t&&this.addBinding(e,t)},cancel:()=>this.removeBinding(e,t),active:this.bindings[e.id]===t}}removeBinding(e,t){if(!this.bindings[e.id])return void de.debug("Trying to unbind unbound command");this.bindings[e.id]===t?delete this.bindings[e.id]:de.debug("Trying to unbind unbound callback")}issueCommand(e,t=!0){const s=this.bindings[e.id];return s?this.issueCommandHelper(e,s,t):this.ignoreUnboundCommands?Promise.resolve({}):Promise.reject("Command not bound: "+e.id)}issueCommandHelper(e,t,s=!0){return this.hookedCommands[e.id]&&!this.hookedCommands[e.id].resolving?this.issueHookCommand(e):t(e.payload)}issueCommandWhenBound(e){const t=new r.iB;return this.issueCommand(e).then((e=>t.resolve(e))).catch((s=>{this.queuedCommands[e.id]||(this.queuedCommands[e.id]=[]),this.queuedCommands[e.id].push({command:e,deferred:t})})),t.nativePromise()}callQueuedCommands(e){const t=[];this.queuedCommands[e]&&(this.queuedCommands[e].forEach((e=>{t.push(this.issueCommand(e.command).then((t=>e.deferred.resolve(t))))})),Promise.all(t).then((()=>{delete this.queuedCommands[e]})))}hookCommand(e,t,s){let i=this.hookedCommands[e.id];if(i){if(t&&null!==i.preCommandCallback)throw Error(`Command ${e.name} has already been pre hooked`);if(!t&&null!==i.postCommandCallback)throw Error(`Command ${e.name} has already been post hooked`)}else i=this.hookedCommands[e.id]={preCommandCallback:null,postCommandCallback:null,resolving:!1};return l((()=>{t?i.preCommandCallback=s:i.postCommandCallback=s}),(()=>{t?i.preCommandCallback=null:i.postCommandCallback=null}),!0)}async issueHookCommand(e){const t=this.hookedCommands[e.id],s=this.bindings[e.id],i=e.payload,r=t.preCommandCallback,n=t.postCommandCallback;try{r&&await r(i),t.resolving=!0;const o=await this.issueCommandHelper(e,s,!0);return t.resolving=!1,n&&await n(i),o}catch(e){throw Error(`Could not completely issueHookCommand - ${e}`)}}}class ce{constructor(){this.bindings=[]}init(e,t){return Promise.resolve()}onUpdate(e){}dispose(e){for(const e of this.bindings)null==e||e.cancel();this.bindings=[]}}class ue{constructor(e){this._mask=e}get mask(){return this._mask}addLayers(e){this._mask|=e.mask}removeLayers(e){return this._mask&=~e.mask}clone(){return new ue(this._mask)}}class me{static get ALL(){return new ue(-1)}static get NONE(){return new ue(0)}static get DEFAULT(){return new ue(1)}constructor(){this.layerRegistry=[],this.unusedLayers=[];for(let e=1;e<32;e++)this.unusedLayers.push(e)}claimLayer(e){const t=this.getLayer(e);if(t.mask)return t;if(0===this.unusedLayers.length)throw Error("All render layers have already been claimed");const s=this.unusedLayers[0];return this.layerRegistry[s]=e,this.unusedLayers.shift(),new ue(1<<s)}getLayer(e){const t=this.layerRegistry.indexOf(e);return-1!==t?new ue(1<<t):me.NONE}disposeLayer(e){const t=this.layerRegistry.indexOf(e);-1!==t&&this.unusedLayers.push(t)}}var fe;!function(e){e[e.Begin=0]="Begin",e[e.Logic=1]="Logic",e[e.Render=2]="Render",e[e.End=3]="End"}(fe||(fe={}));class pe{constructor(e,t){this.data=e,this.inputs=t,this._outputCache=null}run(){this._outputCache=this.onRun(this.inputs)}invert(){if(!this._outputCache)throw new Error("Attempted to inverse a data action before running it");this.onInvert(this._outputCache,this.inputs),this._outputCache=null}merge(e){return!1}get output(){if(this._outputCache)return this._outputCache;throw new Error("Tried to read output of an action before it was run")}logInfo(){return Object.assign({name:this.name()},this.inputs)}}class ge{constructor(e){this.afterAction=e,this.actions=[]}run(){for(const e of this.actions)e.run(),this.afterAction()}invert(){for(let e=this.actions.length-1;e>=0;e--){this.actions[e].invert(),this.afterAction()}}merge(e){if(0===this.actions.length)this.actions.push(e);else{const t=this.actions[this.actions.length-1];t&&t.merge(e)||this.actions.push(e)}return!0}logInfo(){return this.actions.map((e=>Object.assign({undo:!0},e.logInfo())))}lastAction(){return this.actions.length?this.actions[this.actions.length-1]:null}}const be=new r.Vy("undo-stack");class ye{constructor(e){this.afterAction=e,this.undoBuffer=new r.CZ(50),this.finalized=!1,this.length=new M(0)}push(e){(this.undoBuffer.isEmpty()||this.finalized)&&(this.undoBuffer.push(new ge(this.afterAction)),this.finalized=!1,this.length.value=this.undoBuffer.count);const t=this.undoBuffer.peek();t&&t.merge(e)}pushUndoStep(e){this.undoBuffer.isEmpty()||this.finalized||(be.warn("Adding an UndoStep when the previous step is not finalized."),this.finalize()),this.undoBuffer.push(e),this.length.value=this.undoBuffer.count}pop(){const e=this.undoBuffer.pop();return this.length.value=this.undoBuffer.count,e}peek(){const e=this.undoBuffer.peek();return this.length.value=this.undoBuffer.count,e}finalize(){this.finalized=!0}clear(){this.undoBuffer.clear(),this.length.value=this.undoBuffer.count}}class ve{constructor(){this.msgId=-1}setID(e){if(-1!==this.msgId)throw Error("Message.msgId can only be set once.");this.msgId=e}}class we extends ve{constructor(e){super(),this.feature=e}}const Ce=new r.Vy("message-bus");var Oe,ke,_e;!function(e){e[e.PERMANENT=0]="PERMANENT",e[e.ONCE=1]="ONCE"}(Oe||(Oe={}));class Pe{constructor(){this.typeLookup=new r.b0,this.callbacks={},this.messageQueue=[],this.messageCount=0}subscribe(e,t,s=Oe.PERMANENT){return l((()=>this._subscribe(e,t,s)),(()=>this.unsubscribe(e,t)),!0,(0,r.sb)(e))}_subscribe(e,t,s=Oe.PERMANENT){const i=this.typeLookup.getKeyByType(e,!0);this.callbacks[i]||(this.callbacks[i]=[]),this.callbacks[i].push({type:s,callback:t})}unsubscribe(e,t){const s=this.typeLookup.getKeyByType(e);s?this.unsubscribeByIndex(s,t):Ce.debug(`Message callback not bound for Type: ${e.name}`)}unsubscribeByIndex(e,t){const s=this.callbacks[e].findIndex((e=>e.callback===t));-1!==s?this.callbacks[e].splice(s,1):Ce.debug(`Message callback not bound for TypeIndex: ${e}`)}broadcast(e){if(e.setID(this.messageCount++),this.messageQueue.push(e),1===this.messageQueue.length){for(const e of this.messageQueue){const t=this.typeLookup.getKeyByInstance(e);if(!t)continue;const s=this.callbacks[t].slice();for(const i of s)i.callback(e),i.type===Oe.ONCE&&this.unsubscribeByIndex(t,i.callback)}this.messageQueue=[]}}}class De extends ve{constructor(e,t){super(),this.x=e,this.y=t}}class Ee extends ve{constructor(e,t){super(),this.width=e,this.height=t}}class Le extends ve{constructor(e,t){super(),this.phase=e,this.application=t}}class Ae extends ve{constructor(e){super(),this.application=e}}class Se extends ve{constructor(e){super(),this.application=e}}!function(e){e[e.Immediate=0]="Immediate",e[e.NextFrame=1]="NextFrame",e[e.Duration=2]="Duration",e[e.Manual=3]="Manual",e[e.Debounced=4]="Debounced"}(ke||(ke={})),function(e){e.added="added",e.removed="removed",e.updated="updated"}(_e||(_e={}));class Re{constructor(e,t,s){this.index=e,this.action=t,this.diff=s}}class Ie{constructor(e,t){if(this.changedHandlers=[],this.awaitingInvoke=!1,this.diffRecord=[],this.targetMonitors={},this.triggerChangeHandlers=this.invokeChangeHandlers.bind(this),this.config=e,this.updatePhaseSync=t,this.config.aggregationType===ke.NextFrame){if(!t)throw Error("UpdatePhaseSync required for NextFrame aggregation")}else{if(this.config.aggregationType===ke.Duration)throw Error("Aggregation Type not implemented");this.config.aggregationType===ke.Debounced&&(this.triggerChangeHandlers=(0,r.sg)(this.invokeChangeHandlers.bind(this),e.aggregationDuration))}}hasDiffRecord(){return this.diffRecord.length>0}clearDiffRecord(){this.diffRecord=[];for(const e in this.targetMonitors){const t=this.targetMonitors[e];t.hasDiffRecord()&&t.clearDiffRecord()}this.awaitingInvoke=!1}onChanged(e){this.changedHandlers.push(e)}removeOnChanged(e){(0,r.Nz)(this.changedHandlers,e)}invokeCallbacks(e){if(this.changedHandlers.length>0)for(const t of this.changedHandlers)t(e)}invokeChangeHandlers(e){var t;switch(this.config.aggregationType){case ke.Immediate:case ke.Debounced:this.invokeCallbacks(e);break;case ke.NextFrame:this.awaitingInvoke||(this.awaitingInvoke=!0,null===(t=this.updatePhaseSync)||void 0===t||t.after(fe.End).then((()=>{this.awaitingInvoke&&(this.invokeCallbacks(e),this.awaitingInvoke=!1)})));case ke.Manual:}}}class Me{constructor(e,t,s){this.updatePhaseSync=s,this.target=e,this.clearDiffRecord(),this.aggregationType=t.aggregationType,this.aggregationType===ke.Debounced&&(this.handleAggregation=(0,r.sg)(this.handleAggregation.bind(this),t.aggregationDuration||30)),this.target.onChanged((()=>{this.diffRecord=(0,r.bB)(this.originalData,(0,r.A4)(this.target),t.shallow),this.handleAggregation()})),this.changedHandlers=[]}hasDiffRecord(){return Object.keys(this.diffRecord).length>0}getDiffRecord(){return this.diffRecord}clearDiffRecord(){this.originalData=(0,r.A4)(this.target),this.diffRecord={}}onChanged(e){this.changedHandlers.push(e)}removeOnChanged(e){(0,r.Nz)(this.changedHandlers,e)}commitChanges(){this.triggerChangeHandlers(this.diffRecord)}handleAggregation(){switch(this.aggregationType){case ke.Immediate:this.triggerChangeHandlers(this.diffRecord);break;case ke.NextFrame:if(!this.updatePhaseSync)throw new Error("handleAggregation() -> Next frame aggregation requested, but updatePhaseSync is null");this.nextFramePromise||(this.nextFramePromise=this.updatePhaseSync.after(fe.Begin).then((()=>{this.triggerChangeHandlers(this.diffRecord)})).finally((()=>{this.nextFramePromise=void 0})));break;case ke.Debounced:this.triggerChangeHandlers(this.diffRecord);break;case ke.Duration:throw new Error("AggregationType.Duration: Please implement me :)");case ke.Manual:}}triggerChangeHandlers(e){if(this.changedHandlers.length>0)for(const t of this.changedHandlers)t(e)}}class Te extends Ie{constructor(e,t,s){super(t,s),this.target=e;for(const i of e.keys){const r=e.get(i),n=new Me(r,t,s);n.onChanged(this.triggerChangeHandlers),this.targetMonitors[i]=n}const i={onAdded:(e,i)=>{const n=new Me(e,t,s);n.onChanged(this.triggerChangeHandlers),this.targetMonitors[i]=n;const o=this.diffRecord.findIndex((e=>e.index===i));-1!==o&&this.diffRecord.splice(o,1);const a=new Re(i,_e.added,(0,r.A4)(e));-1===o&&this.diffRecord.push(a),this.triggerChangeHandlers(a)},onRemoved:(e,t)=>{delete this.targetMonitors[t];const s=this.diffRecord.findIndex((e=>e.index===t));-1!==s&&this.diffRecord.splice(s,1);const i=new Re(t,_e.removed,(0,r.A4)(e));-1===s&&this.diffRecord.push(i),this.triggerChangeHandlers(i)}};this.target.onElementChanged(i)}commitChanges(){this.invokeCallbacks(this.getDiffRecord())}getDiffRecord(){const e=[];for(const t in this.targetMonitors){const s=this.targetMonitors[t];if(s.hasDiffRecord()){const i=s.getDiffRecord(),n=this.diffRecord.findIndex((e=>e.index===t));-1!==n?(0,r.h1)(this.diffRecord[n].diff,i):e.push(new Re(t,_e.updated,i))}}return this.diffRecord.concat(e)}}class Ne extends O{constructor(e,t){super(),this.computation=e,this.updateValue=()=>{const e=this.computation();Array.isArray(e)&&Array.isArray(this._lastValue)&&(0,r.vq)(e,this._lastValue)?this._dirtyObservable=!1:e!==this._lastValue&&(this._prevValue=this._lastValue,this._lastValue=e,this.setDirty(!0))},this._lastValue=this.computation(),this._prevValue=null,this._subscriptions=new n(...t.map((e=>e(this.updateValue))))}get value(){return this._lastValue}get prevValue(){return this._prevValue}renew(){this._subscriptions.renew()}cancel(){this._subscriptions.cancel()}notifyObserver(e){e(this._lastValue)}}class Be extends O{constructor(){super(),this.isObservableArray=!0,this.elements=[]}static from(...e){const t=new Be;return t.push(...e),t}push(...e){for(const t of e)this.elements.push(t),this.addChildObservable(t);return this.setDirty(),this.length}concat(e){const t=this.elements.length;this.elements=this.elements.concat(...e);for(let e=t;e<this.elements.length;e++)this.addChildObservable(this.elements[e]);return this.setDirty(),this.length}replace(e){for(const e of this.elements)this.removeChildObservables(e);return this.elements=[],this.concat(e)}remove(e){if(e<0||e>=this.length)throw new Error(`Index ${e} not in range of ObservableArray`);const[t]=this.elements.splice(e,1);this.removeChildObservables(t),this.setDirty()}clear(){for(;this.length;)this.remove(0)}update(e,t){const s=this.elements[e];s!==t&&(this.elements[e]=t,this.removeChildObservables(s),this.addChildObservable(t),this.setDirty())}get length(){return this.elements.length}set length(e){if(e<this.elements.length){for(let t=this.elements.length-1;t>=e;t--){const e=this.elements[t];this.removeChildObservables(e)}this.elements.length=e,this.setDirty()}}entries(){return this.elements.entries()}values(){return[...this.elements]}filter(e){return this.elements.filter(e)}find(e){return this.elements.find(e)}*[Symbol.iterator](){for(const e of this.elements)yield e}map(e,t){return this.elements.map(e,t)}forEach(e,t){this.elements.forEach(e,t)}sort(e){this.elements.sort(e)}get(e){return this.elements[e]}findIndex(e,t){return this.elements.findIndex(e,t)}indexOf(e){return this.elements.indexOf(e)}splice(e,t,...s){let i;if(s.length){i=this.elements.splice(e,t,...s);for(const e of s)this.addChildObservable(e)}else i=this.elements.splice(e,t);for(const e of i)this.removeChildObservables(e);return this.setDirty(),i}insert(e,t){if(e>this.elements.length)throw new Error(`Tried to insert at index ${e} in an array that's only ${this.elements.length} long`);e!==this.elements.length?(this.elements.splice(e,0,t),this.addChildObservable(t),this.setDirty()):this.push(t)}shift(){const e=this.elements.shift();return e&&(this.removeChildObservables(e),this.setDirty()),e}move(e,t){if(t>this.elements.length-1)throw Error("Index to move to is out of bounds");const s=this.elements[e];this.elements.splice(e,1),this.elements.splice(t,0,s),this.setDirty()}includes(e,t){return this.elements.includes(e,t)}some(e,t){return this.elements.some(e,t)}every(e,t){return this.elements.every(e,t)}onElementChanged(e){let t=this.elements.slice();return this.onChanged((()=>{for(const s in t){const i=parseInt(s,10);e.onRemoved&&void 0===this.get(i)&&e.onRemoved(t[i],i)}for(const s in this.elements){const i=parseInt(s,10),r=this.get(i);void 0===t[i]?e.onAdded&&e.onAdded(r,i):(O.isObservable(r)&&r._dirtyObservable||r!==t[i])&&(e.onUpdated?e.onUpdated(r,i):e.onRemoved&&null===r&&e.onRemoved(t[i],i))}t=this.elements.slice()}))}deepCopy(){return this.map((e=>(0,r.A4)(e)))}}const xe=e=>{const t=new Be;return e&&t.concat(e),t};function Ue(e){return(0,r.Et)(e)?""+e:e}class Ge extends O{constructor(){super(),this.map={},this._keysSet=new Set,this._keysList=[]}get keys(){return this._keysList.slice()}get values(){return this._keysList.map((e=>this.get(e)))}sort(e){this._keysList.sort(((t,s)=>{const i=this.get(t),r=this.get(s);return e?e(i,r):0}))}entries(){const e=[];for(const t in this.map)e.push([t,this.map[t]]);return e}get length(){return this._keysList.length}*[Symbol.iterator](){for(const e of this._keysList)yield this.get(e)}get(e){return this.map[e]}has(e){return void 0!==this.map[e]}set(e,t){e=Ue(e);this.map[e]!==t&&(this.removeChildObservables(this.map[e]),this.addChildObservable(t),this.map[e]=t,this._keysSet.has(e)||(this._keysList.push(e),this._keysSet.add(e)),this.setDirty())}clear(){if(this.length>0){for(const e in this.map)this.removeChildObservables(this.map[e]);this.map={},this._keysSet.clear(),this._keysList=[],this.setDirty()}}replace(e){this.clear();for(const t in e)this.set(t,e[t])}delete(e){e=Ue(e),this.removeChildObservables(this.map[e]);const t=this.map.hasOwnProperty(e);return delete this.map[e],t&&(this._keysSet.delete(e),this._keysList.splice(this._keysList.indexOf(e),1),this.setDirty()),t}forEach(e,t){for(const s of this._keysList){const i=this.map[s];e.call(t,i,s,this)}}onElementChanged({onAdded:e,onRemoved:t,onUpdated:s}){return this.onElementsChanged((({added:i,removed:r,updated:n})=>{if(r&&t)for(const[e,s]of r)t(s,e);if(i&&e)for(const[t,s]of i)e(s,t);if(n&&s)for(const[e,t]of n)s(t,e)}))}onElementsChanged(e){let t=Object.assign({},this.map);return this.onChanged((()=>{const s={};for(const e in t)this.has(e)||(s.removed||(s.removed=[])).push([e,t[e]]);for(const e of this._keysList){const i=this.get(e);void 0===t[e]?(s.added||(s.added=[])).push([e,i]):(O.isObservable(i)&&i._dirtyObservable||i!==t[e])&&(null!==i?(s.updated||(s.updated=[])).push([e,i]):(s.removed||(s.removed=[])).push([e,t[e]]))}t=Object.assign({},this.map),e(s)}))}deepCopy(){const e={};for(const t of this._keysList)e[t]=(0,r.A4)(this.map[t]);return e}}const Fe=(e={})=>{const t=new Ge;return t.replace(e),t};var Ve;!function(e){e.LOW="low",e.NORMAL="normal"}(Ve||(Ve={}));class He extends O{constructor(e){super(),this.priority=Ve.NORMAL,this.filters=new Map,this.view=[],this._keys=new Map,this._dirty=!1,this.sortNeeded=!1,this._diff={},this.map=e,this.applyFilters(),this.map.onElementsChanged((({added:e,removed:t,updated:s})=>{this._diff={added:e,removed:t,updated:s},this._diff.added&&(this._diff.added=this._diff.added.filter((([e,t])=>this.testFilters(t)))),this._diff.updated&&(this._diff.updated=this._diff.updated.filter((([e,t])=>this.testFilters(t)))),this._diff.removed&&(this._diff.removed=this._diff.removed.filter((([e,t])=>this.testFilters(t)))),this.atomic((()=>{if(t)for(const[e,s]of t)this.onRemoved(e,s);if(e)for(const[t,s]of e)this.onAdded(t,s);if(s)for(const[e,t]of s)this.onUpdated(e,t)}))})),this.map.onChanged((()=>{this.sortNeeded&&(this.applySort(),this.setDirty(),this.sortNeeded=!1)}))}onElementsChanged(e){return this.onChanged((()=>{e(this._diff)}))}onElementChanged({onAdded:e,onRemoved:t,onUpdated:s}){return this.onElementsChanged((({added:i,removed:r,updated:n})=>{if(r&&t)for(const[e,s]of r)t(s,e);if(i&&e)for(const[t,s]of i)e(s,t);if(n&&s)for(const[e,t]of n)s(t,e)}))}has(e){return this._keys.has(e)}get(e){return this.has(e)?this.map.get(e):void 0}setFilter(e,t){return l((()=>{this.filters.set(e,t),this.applyFilters(void 0,!1,!0)}),(()=>this.clearFilter(e)),!0)}clearFilter(e){return!!this.filters.has(e)&&(this.filters.delete(e),this.applyFilters(void 0,!1,!0),!0)}clearFilters(){this.filters.clear(),this.applyFilters(void 0,!1,!0)}sort(e){this.compareFunc=e,this.applySort(),this.setDirty()}*[Symbol.iterator](){for(const e of this.view)yield e}get length(){return this.view.length}groupBy(e){const t={};for(const s of this.view){const i=String(s[e]);t[i]||(t[i]=[]),t[i].push(s)}return t}get values(){return this.view.slice()}entries(){return[...this._keys.entries()]}forEach(e,t){for(const[s,i]of this._keys)e.call(t,i,s,this)}setDirty(e=!0){this.priority===Ve.LOW?this._dirty||(this._dirty=!0,requestAnimationFrame((()=>{this._dirty=!1,super.setDirty(e)}))):super.setDirty(e)}add(e){if(this.has(e))return!1;const t=this.map.get(e);return this._keys.set(e,t),this.view.push(t),!0}delete(e){const t=this._keys.get(e);if(!t)return!1;this._keys.delete(e);const s=this.view.indexOf(t);return-1!==s&&this.view.splice(s,1),!0}testFilters(e){return[...this.filters.values()].every((t=>t(e)))}applyFilters(e,t=!1,s=!1){s&&(this._diff={});let i=!1;const r=e?[e]:this.map.keys;for(const e of r){const t=this.map.get(e),r=this.testFilters(t);r&&this.add(e)?(s&&(this._diff.added||(this._diff.added=[]),this._diff.added.push([e,t])),i=!0):!r&&this.delete(e)&&(s&&(this._diff.removed||(this._diff.removed=[]),this._diff.removed.push([e,t])),i=!0)}e&&this.has(e)&&(s&&(this._diff.updated||(this._diff.updated=[]),this._diff.updated.push([e,this.map.get(e)])),i=!0),i&&(t?this.sortNeeded=!0:(this.applySort(),this.setDirty()))}applySort(){this.compareFunc&&this.view.sort(this.compareFunc)}onRemoved(e,t){this.has(e)&&this.testFilters(t)&&this.delete(e)&&this.setDirty()}onAdded(e,t){this.testFilters(t)&&this.applyFilters(e,!0,!1)}onUpdated(e,t){const s=this._keys.get(e),i=this.view.findIndex((e=>e===s));-1!==i&&(this.view[i]=t,this._keys.set(e,t)),this.applyFilters(e,!0,!1)}}class je extends O{constructor(){super(...arguments),this.elements=new Set}add(e){return this.has(e)||(this.elements.add(e),this.addChildObservable(e),this.setDirty()),this}clear(){this.atomic((()=>{const e=[...this.elements];for(const t of e)this.delete(t)}))}delete(e){const t=this.elements.delete(e);return t&&(this.removeChildObservables(e),this.setDirty()),t}has(e){return this.elements.has(e)}forEach(e,t){this.elements.forEach(e,t)}get size(){return this.elements.size}*entries(){yield*this.elements.entries()}*keys(){yield*this.elements.keys()}*values(){yield*this.elements.values()}*[Symbol.iterator](){yield*this.elements}addValues(e){for(const t of e)this.add(t);return this}replace(e){this.clear();for(const t of e)this.add(t)}get[Symbol.toStringTag](){return"ObservableSet"}filter(e,t){const s=[...this.elements].filter(e,t);return new Set(s)}find(e,t){return[...this.elements].find((s=>e.call(t,s,this)))}map(e,t){const s=[...this.elements].map(e,t);return new Set(s)}deepCopy(){const e=new Set;for(const t of this)e.add((0,r.A4)(t));return e}onElementChanged(e){let t=new Set(this);return this.onChanged((()=>{for(const s of t)e.onRemoved&&!this.has(s)&&e.onRemoved(s,s);for(const s of this.elements)t.has(s)?O.isObservable(s)&&s._dirtyObservable&&e.onUpdated&&e.onUpdated(s,s):e.onAdded&&e.onAdded(s,s);t=new Set(this)}))}}class $e{constructor(){this.observers=new Set}observe(e){this.observers.add(e);const t=this;return{renew(){t.observers.add(e)},cancel(){t.removeObserver(e)}}}removeObserver(e){this.observers.delete(e)}notify(){for(const e of this.observers)e.notify()}}function ze(e){let t;const s=new Map,i=new Map,r=new Set,n=new Map,o=[],a=e=>{if(t!==e){if(o.forEach((e=>e.cancel())),o.length=0,t=e,o.push(t.onChanged((e=>{r.forEach((t=>t(e)))}))),t instanceof P)for(const[e,s]of n.entries())o.push(t.onPropertyChanged(e,(e=>{s.forEach((t=>t(e)))})));for(const[t,i]of s.entries())i.currentObservable=e[t];i.clear()}},h={get(e,a,h){switch(a){case"currentObservable":return t;case"onChanged":return(...e)=>{const t=e[0];return r.add(t),l((()=>r.add(t)),(()=>r.delete(t)))};case"onPropertyChanged":return(e,s)=>{if(!(t instanceof P))return;let i=n.get(e);return i||(i=new Set,n.set(e,i),o.push(t.onPropertyChanged(e,(t=>{if(!i)throw new Error(`No observers for property "${String(e)}"`);i.forEach((e=>e(t)))})))),i.add(s),l((()=>null==i?void 0:i.add(s)),(()=>null==i?void 0:i.delete(s)))};case"removeOnPropertyChanged":return(e,t)=>{const s=n.get(e);s&&(s.delete(t),0===s.size&&n.delete(e))};default:return"function"==typeof t[a]?(i.has(a)||i.set(a,t[a].bind(t)),i.get(a)):s.has(a)?s.get(a):Reflect.get(t,a,h)}},set:(e,s,i)=>"currentObservable"===s?(a(i),!0):Reflect.set(t,s,i)};a(e);for(const t in e)e.hasOwnProperty(t)&&e[t]instanceof O&&s.set(t,ze(e[t]));return new Proxy(e,h)}var Qe;!function(e){e.BLURS="blurs",e.BLUR_SUGGESTIONS="blur-suggestions",e.FLOORS="floors",e.HIGHLIGHTS="highlights",e.LABELS="labels",e.MATTERTAGS="mattertags",e.MEASUREMENTS="measurements",e.NOTES="notes",e.OBJECT_ANNOTATIONS="objectAnnotations",e.ORDERED_LISTS="orderedLists",e.PHOTOS="photos",e.PLUGINS="plugins",e.SETTINGS="settings",e.START_LOCATION="startlocation",e.SWEEPS="sweeps",e.LAYERS="layers",e.ROOM_BOUNDS="room_bounds"}(Qe||(Qe={}));class Ke{constructor(e){this.config=e}serialize(e){const{serializer:t}=this.config;if(!e||!t)return null;const s={};for(const i in e){const r=t.serialize(e[i]);r&&(s[i]=r)}return s}deserialize(e){const{deserializer:t}=this.config;if(!e||!t)return{};const s={};for(const i in e){const r=t.deserialize(e[i]);r&&(s[i]=r)}return s}}class qe{constructor(e){this.config=e}serialize(e){const{serializer:t}=this.config;if(!e||!Array.isArray(e)||!t)return null;const s=[];for(const i of e){const e=t.serialize(i);e&&s.push(e)}return s}deserialize(e){const{deserializer:t}=this.config;if(!e||!Array.isArray(e)||!t)return null;const s=[];for(const i of e){const e=t.deserialize(i);e&&s.push(e)}return s}}var We=s(68920),Ze=(s(38630),s(40157));const Je=new r.Vy("module-loader");var Ye;!function(e){e[e.Registered=0]="Registered",e[e.Loading=1]="Loading",e[e.Initialized=2]="Initialized",e[e.Unloaded=3]="Unloaded"}(Ye||(Ye={}));class Xe{constructor(e=new F.mc){this.container=e,this.symbolMap=new Map}registerModule(e,t){if(this.symbolMap.has(e))throw Error(`Type ${String(e)} already registered`);const s={loadClass:t,ctorPromise:new We.i,initPromise:new We.i,state:Ye.Registered};return this.symbolMap.set(e,s),this.container.bindAsyncFactory(e,(()=>s.initPromise.nativePromise())),s}moduleRegistered(e){return this.symbolMap.has(e)}moduleLoaded(e){const t=this.symbolMap.get(e);return!!t&&![Ye.Registered,Ye.Unloaded].includes(t.state)}getModule(e){const t=this.symbolMap.get(e);if(!t)throw Error(`Trying to get ${String(e)} before it was registered!`);if(t.state===Ye.Unloaded)throw Error(`${String(e)} module unloaded`);return t.initPromise.nativePromise()}getModuleSync(e){const t=this.symbolMap.get(e);return t?t.state!==Ye.Initialized?null:t.module||null:null}loadModule(e,t,s={}){const i=this.symbolMap.get(t);if(!i)throw Error(`${String(t)} not found`);if(i.state===Ye.Initialized)return i;if(i.state!==Ye.Registered&&i.state!==Ye.Unloaded)throw Error(`${String(t)} already loading`);return i.state=Ye.Loading,i.loadClass().then((async r=>{if("function"!=typeof r&&(r=r.default),!r)throw new Error(`${String(t)} has no default export during module loading`);let n;if(Reflect.hasOwnMetadata(Ze.a4,r)){const e=new F.mc(this.container);e.bindClass(r),n=await e.resolve(r)}else n=new r;i.ctorPromise.resolve(n).then((()=>{const r=Date.now();let o=!1;setTimeout((()=>{o||Je.debug(`${n.name} init took over 2 seconds`)}),2e3),n.init(s,e).then((()=>{Je.debug(`${n.name} init took ${(Date.now()-r)/1e3} secs.`),o=!0,i.state=Ye.Initialized,i.module=n,i.initPromise.resolve(n),this.container.bindConstant(t,n)})).catch((e=>{i.initPromise.reject(e)}))}))})).catch((e=>{Je.error(`Failed to load es6Module for ${String(t)}: ${e}`),i.initPromise.reject(e)})),i}whenQueueEmpties(e,t=[]){const s=[],i=new Map;for(const[e,r]of this.symbolMap)r.state!==Ye.Loading||t.includes(e)||(s.push(r.initPromise),i.set(e,r.initPromise));for(const[t,s]of i){const i=setTimeout((()=>Je.debugInfo("still loading",t)),e);s.then((()=>clearTimeout(i)))}return We.i.all(s).nativePromise()}unloadModule(e){const t=this.symbolMap.get(e);if(!t)throw Error("Attempting to unload unregistered module");if(t.state===Ye.Unloaded||t.state===Ye.Registered)throw Error("Attempting to unload not-loaded module");t.state=Ye.Unloaded,t.ctorPromise=new We.i,t.initPromise=new We.i,t.module=void 0,this.container.removeBinding(e,!1,!0)}}function et(e,t){for(const s in t)if(e===t[s].module)return s.replace("Symbol(","Module(");return"[Unknown module]"}class tt{constructor(e,t,s){this.engine=e,this.moduleLookup=t,this.fetchedModules=[],this.messageBus=e.msgBus,this.market=new st(e.market,s),this.commandBinder=e.commandBinder,this.generatorSpreader=e.generatorSpreader,this.uniqueId=e.uniqueId,this.diContainer=e.diContainer,this.getModuleBySymbolSync=e.getModuleBySymbolSync.bind(e),this.tryGetModuleBySymbolSync=e.tryGetModuleBySymbolSync.bind(e),this.addComponent=e.addComponent.bind(e),this.getComponentByType=e.getComponentByType.bind(e),this.getComponents=e.getComponents.bind(e),this.removeComponent=e.removeComponent.bind(e),this.subscribe=e.subscribe.bind(e),this.unsubscribe=e.unsubscribe.bind(e),this.broadcast=e.broadcast.bind(e),this.claimRenderLayer=e.claimRenderLayer.bind(e),this.getRenderLayer=e.getRenderLayer.bind(e),this.disposeRenderLayer=e.disposeRenderLayer.bind(e),this.startGenerator=e.startGenerator.bind(e),this.stopGenerator=e.stopGenerator.bind(e),this.after=e.after.bind(e),this.tick=e.tick.bind(e),this.toggleRendering=e.toggleRendering.bind(e),e.triggerRenderViewport&&(this.triggerRenderViewport=e.triggerRenderViewport.bind(e))}getModuleBySymbol(e){const t=Date.now();return this.engine.getModuleBySymbol(e).then((s=>{const i=Date.now();return this._track(e,t,i,s),s}))}getModuleBySymbolSync(e){return this._track(e,Date.now(),Date.now()),this.engine.getModuleBySymbolSync(e)}tryGetModuleBySymbolSync(e){return this._track(e,Date.now(),Date.now()),this.engine.getModuleBySymbolSync(e)}getLoadedDependencies(){return[...this.fetchedModules,...this.market.getLoadedDependencies()]}get msgBus(){return this.messageBus}_track(e,t,s,i){const r=null!=i?i:this.engine.tryGetModuleBySymbolSync(e);this.fetchedModules.push({moduleName:et(r,this.moduleLookup),isModule:!0,startAwait:t,finishAwait:s})}}class st{constructor(e,t){this.market=e,this.onRegisterData=t,this.fetchedData=[],this._register=e.register.bind(e),this._unregister=e.unregister.bind(e)}register(e,t){this._register(e,t),this.onRegisterData(t.name,Date.now())}unregister(e){this._unregister(e)}waitForData(e){const t=Date.now();return this.market.waitForData(e).then((e=>{const s=Date.now(),i=e.name.startsWith("data:")?e.name:`data:${e.name}`;return this.fetchedData.push({moduleName:i,isModule:!1,startAwait:t,finishAwait:s}),e}))}tryGetData(e){const t=Date.now(),s=this.market.tryGetData(e);if(s){const e=Date.now(),i=s.name.startsWith("data:")?s.name:`data:${s.name}`;return this.fetchedData.push({moduleName:i,isModule:!1,startAwait:t,finishAwait:e}),s}return null}getLoadedDependencies(){return this.fetchedData}}const it="Data not present.";class rt{constructor(){this.log=new r.Vy("market"),this.typeLookup=new r.b0,this.store={},this.firstUpdatePromises={}}register(e,t){const s=this.typeLookup.getKeyByType(e,!0);if(this.store[s])throw Error("Data can only be registered to one Module");this.store[s]=t,t.commit(),s in this.firstUpdatePromises&&(this.firstUpdatePromises[s].resolve(this.store[s]),delete this.firstUpdatePromises[s])}unregister(e){const t=this.typeLookup.getKeyByType(e,!0);if(!this.store[t])throw Error("No Data was registered to the Module");delete this.store[t]}getData(e){const t=this.typeLookup.getKeyByType(e);if(t in this.store)return this.store[t];throw Error(it)}waitForData(e){const t=this.typeLookup.getKeyByType(e,!0);return t in this.store?Promise.resolve(this.store[t]):(this.firstUpdatePromises[t]||(this.firstUpdatePromises[t]=new r.iB,setTimeout((()=>{r.Vy.level>=3&&!(t in this.store)&&this.log.debug(`still waiting for ${e.name}-data after 5 seconds`)}),5e3)),this.firstUpdatePromises[t].nativePromise())}tryGetData(e){try{return this.getData(e)}catch(e){if(e.message!==it)throw this.log.error("tryGetData",e.message),e}return null}}class nt{constructor(){this.phaseTimes=[],this.modules={},this.onDataRegister=this.onDataRegister.bind(this),this.addAppPhase(B.UNINITIALIZED),window.profilingData={phaseTimes:this.phaseTimes,modules:this.modules,rows:[]}}addAppPhase(e){e!==B.PLAYING&&e!==B.ERROR||(window.profilingData.rows=[...Object.values(this.modules)].sort(((e,t)=>e[4]-t[4]))),this.phaseTimes[e]=Date.now()}addModuleLoadTime(e,t,s,i){const n=[i.map((e=>`${e.moduleName}`))].join(","),o=i.reduce(((e,t)=>e+t.finishAwait-t.startAwait),0),a=Math.min(100,o/(s-t)*100);null==e&&r.Vy.for(this).warnError("Module name is required"),this.modules[e]=[e,e,null,t,s,null,a,n]}onDataRegister(e,t){null==e&&r.Vy.for(this).warnError("Data.name is required"),e.startsWith("data:")||(e=`data:${e}`),this.modules[e]=[e,e,null,t,t,null,0,""]}listDependencies(){var e;const t=Object.entries(this.modules).map((([e,t])=>{var s;return{key:e,uses:(null===(s=t[7])||void 0===s?void 0:s.split(",").filter((e=>!!e)).sort(((e,t)=>e.localeCompare(t))))||[],usedBy:[]}}));for(const s of t)for(const i of s.uses)null===(e=t.find((e=>e.key===i)))||void 0===e||e.usedBy.push(s.key);return t.sort(((e,t)=>e.key.localeCompare(t.key)))}listPhaseTimings(){{const e=this.phaseTimes[B.UNINITIALIZED];return this.phaseTimes.map(((t,s)=>({phase:x[s],time:void 0!==t?t-e:void 0}))).filter((e=>void 0!==e.time))}}listModuleTimings(){const e=this.phaseTimes[B.UNINITIALIZED];return Object.values(this.modules).map((t=>({moduleName:t[0],initStart:t[3]-e,initEnd:t[4]-e,initDuration:t[4]-t[3]}))).sort(((e,t)=>e.initStart-t.initStart))}}const ot=new r.Vy("engine");let at=fe.End,ht=0;class dt{constructor(){this.moduleLookup={},this.componentLookup={},this.currentApplication=null,this.moduleProfiler=new nt,this._id=ht++,this._container=function(e,t=Q){const s=new F.mc(t);return K[e]=s,s.bindConstant(V,!1),s.bindConstant("__engineId__",e),s}(this._id),this._container.bindConstant("IEngine",this),this.generatorSpreader=new ae,this.commandBinder=new le,this.market=new rt,this._container.bindConstant("IMarket",this.market),this.messageBus=new Pe,this.engineGenerators=new ie,this.layers=new me,this.symbolLoader=new Xe(this._container),this.afterPhasePromises=[],this.afterPhaseListenerCount=[],this.resetPromises(),ot.debug(`Engine ${this._id} created`),this.subscribe(Le,(e=>this.moduleProfiler.addAppPhase(e.phase)))}get uniqueId(){return this._id}get diContainer(){return this._container}async loadApplication(e,t,s){if(e===this.currentApplication)throw Error("Application already loaded");const i=(this.currentApplication?this.currentApplication.getManifest():[]).map((e=>e.type)),r=e.getManifest(),n=r.map((e=>e.type)),o=this.currentApplication;this.currentApplication=null;const a=r.filter((e=>-1===i.indexOf(e.type)));for(const e of a)this.symbolLoader.moduleRegistered(e.type)||this.registerModule(e);if(o)try{await this.unload(o,(e=>!n.includes(e)))}catch(e){ot.error(e),t&&t(e)}try{this.currentApplication=e,await e.load(this,{coldStart:null===o,autoPlay:s})}catch(e){ot.error(e),t&&t(e)}}async unload(e,t){const s=[...e.getManifest().map((e=>e.type)).filter(t||(()=>!0)).map((e=>this.unloadModuleBySymbol(e))),e.unload(this)];s.length&&await Promise.all(s)}async dispose(){this.currentApplication&&(await this.unload(this.currentApplication),this.currentApplication.stop(),this.currentApplication=null)}registerModule(e){if(this.currentApplication)throw Error("Cannot register modules while application is running");this.symbolLoader.registerModule(e.type,e.promise)}loadModuleBySymbol(e){const t=e,s=t.type;this.moduleLoadInjectionHook&&(t.config=this.moduleLoadInjectionHook(s,t.config||{}));const i=new tt(this,this.moduleLookup,this.moduleProfiler.onDataRegister),r=Date.now(),n=this.symbolLoader.loadModule(i,t.type,t.config);return n.ctorPromise.then((e=>this.moduleLookup[s]={symbol:t.type,module:e,initialized:!1,initPromise:n.initPromise.nativePromise()})),n.initPromise.then((()=>{this.moduleProfiler.addModuleLoadTime(s,r,Date.now(),i.getLoadedDependencies()),this.moduleLookup[s].initialized=!0})),n.initPromise.nativePromise()}setLoadInjection(e){if(void 0!==this.moduleLoadInjectionHook)throw Error("Hook already registered");this.moduleLoadInjectionHook=e}async unloadModuleBySymbol(e){if(!this.symbolLoader.moduleLoaded(e))return void ot.debug(`${String(e)} module already unloaded`);ot.debug(`Unloading ${String(e)} module`);const t=await this.getModuleBySymbol(e),s=this.getModuleIndex(t);this.componentLookup[s]&&(await Promise.all(this.componentLookup[s].map((async e=>{await this.removeComponent(t,e.component),e.component.dispose()}))),this.componentLookup[s]=[]),this.symbolLoader.unloadModule(e),t.dispose(this)}async waitForLoadingModules(e=1e4,t=[]){await Promise.all([this.symbolLoader.whenQueueEmpties(e,t)])}getModuleBySymbol(e){return this.symbolLoader.getModule(e)}getModuleBySymbolSync(e){return this.symbolLoader.getModuleSync(e)}tryGetModuleBySymbolSync(e){try{return this.getModuleBySymbolSync(e)}catch(e){return null}}getComponentByType(e){for(const t in this.moduleLookup){const s=this.moduleLookup[t].module,i=this.getModuleIndex(s),r=this.componentLookup[i]||[];for(const t of r)if(t.component instanceof e)return t.component}return null}async addComponent(e,t){const s=this.getModuleIndex(e);let i=this.componentLookup[s];i||(this.componentLookup[s]=i=[]);let r=-1;for(let e=0;e<i.length;e++)if(i[e].component===t){r=e;break}if(-1===r&&(r=i.push({component:t,active:!1})-1,t.init()),i[r].active)throw Error("Tried to add already active component: "+typeof t);await t.activate(this),i[r].active=!0}async removeComponent(e,t){const s=this.getModuleIndex(e),i=this.componentLookup[s];if(i){let e=null;for(const s of i)if(s.component===t){e=s;break}e&&e.active&&(await t.deactivate(this),e.active=!1)}}tick(){if(at!==fe.End)throw Error("Engine.tick called outside of waiting. Did the engine get called recursively?!");at=fe.Begin,this.resolveAfterPhase(fe.Begin);const e=performance.now(),t=this.lastTick?e-this.lastTick:16;this.lastTick=e,at=fe.Logic,this.generatorSpreader.onUpdate();try{for(const e in this.moduleLookup){const s=this.moduleLookup[e];s&&s.initialized&&s.module.onUpdate(t)}}catch(e){throw ot.error(e),e}this.resolveAfterPhase(fe.Logic),this.engineGenerators.processGenerators(W.Phase,fe.Logic);try{this.renderComponents(t)}catch(e){throw ot.error(e),e}try{at=fe.Render,this.resolveAfterPhase(fe.Render),this.engineGenerators.processGenerators(W.Phase,fe.Render),at=fe.End,this.resolveAfterPhase(fe.End),this.engineGenerators.processGenerators(W.None),this.engineGenerators.processGenerators(W.Promise),this.engineGenerators.processGenerators(W.Duration)}catch(e){throw ot.error(e),e}}triggerRenderViewport(e){for(const t in this.moduleLookup){const s=this.componentLookup[t];if(s)for(const t of s)t.active&&t.component.beforeRenderViewport&&t.component.beforeRenderViewport(e)}}subscribe(e,t,s=Oe.PERMANENT){return this.messageBus.subscribe(e,t,s)}unsubscribe(e,t){this.messageBus.unsubscribe(e,t)}broadcast(e){this.messageBus.broadcast(e)}claimRenderLayer(e){return this.layers.claimLayer(e)}getRenderLayer(e){return this.layers.getLayer(e)}disposeRenderLayer(e){this.layers.disposeLayer(e)}startGenerator(e){this.engineGenerators.startGenerator(e)}stopGenerator(e){this.engineGenerators.stopGenerator(e)}after(e){return this.afterPhaseListenerCount[e]++,this.afterPhasePromises[e].nativePromise()}getModuleIndex(e){for(const t in this.moduleLookup)if(this.moduleLookup[t]&&this.moduleLookup[t].module===e)return t;return""}*getComponents(){for(const e in this.moduleLookup){const t=this.componentLookup[e];if(t)for(const e of t)yield e}}toggleRendering(e,t){const s=this.getModuleIndex(e),i=this.componentLookup[s];if(i)for(const e of i)e.active=t}renderComponents(e){for(const t in this.moduleLookup){const s=this.componentLookup[t];if(s)for(const t of s)t.active&&t.component.beforeRender&&t.component.beforeRender(e)}for(const t in this.moduleLookup){if(!t)continue;const s=this.componentLookup[t];if(s)for(const t of s)t.active&&t.component.render(e)}}resetPromises(){this.resetAfterPhasePromises()}resetAfterPhasePromises(){this.resetAfterPhasePromise(fe.Logic),this.resetAfterPhasePromise(fe.Render),this.resetAfterPhasePromise(fe.Begin),this.resetAfterPhasePromise(fe.End)}resetAfterPhasePromise(e){this.afterPhasePromises[e]=new r.iB,this.afterPhaseListenerCount[e]=0}resolveAfterPhase(e){this.afterPhaseListenerCount[e]>0&&(this.afterPhasePromises[e].resolve(),this.resetAfterPhasePromise(e))}get msgBus(){return this.messageBus}}}}]);